#  Types of Finite Automata

## Course: Formal Languages & Finite Automata
## Author: Gutu Dinu
## Variant: 19

---

## Theory

Finite automata (FA) are mathematical models used to recognize languages, which are sets of strings that can be generated by a formal grammar. 
FA can be deterministic or non-deterministic, depending on the set of rules they follow to recognize strings.

A deterministic finite automaton (DFA) is a finite-state machine that accepts or rejects strings of symbols, 
usually over an alphabet containing a finite number of letters. It is called deterministic because, for each input symbol, 
there is exactly one transition from a given state.
A DFA can recognize only regular languages, which are a subset of the set of all possible languages.

A non-deterministic finite automaton (NFA) is a finite-state machine that accepts or rejects strings of symbols, 
usually over an alphabet containing a finite number of letters. It is called non-deterministic because, 
for each input symbol, there can be multiple transitions from a given state.
An NFA can recognize regular languages and some non-regular languages, which are a superset of the set of all possible regular languages.

The main difference between DFAs and NFAs is that NFAs allow for multiple possible states to be reached from a given state and input symbol, 
whereas DFAs only allow for one state. This means that NFAs can recognize some languages that DFAs cannot. However, 
NFAs are more complex and harder to design and analyze than DFAs.

## Objectives:



- Understand what an automaton is and what it can be used for.

- Continuing the work in the same repository and the same project, the following need to be added: 

1. Provide a function in your grammar type/class that could classify the grammar based on Chomsky hierarchy.

2. For this you can use the variant from the previous lab.

- According to your variant number (by universal convention it is register ID), get the finite automaton definition and do the following tasks:

1. Implement conversion of a finite automaton to a regular grammar.

2. Determine whether your FA is deterministic or non-deterministic.

3. Implement some functionality that would convert an NFA to a DFA.

4. Represent the finite automaton graphically (Optional, and can be considered as a bonus point):


## Implementation description

### Grammar type

```
public String getGrammarType() {
        if (isRegularGrammar()) {
            return "Regular (Type 3)";
        } else if (isContextFreeGrammar()) {
            return "Context-Free (Type 2)";
        } else if (isContextSensitiveGrammar()) {
            return "Context-Sensitive (Type 1)";
        } else {
            return "Recursively enumerable (Type 0)";
        }
    }
```

```
    public boolean isRegularGrammar() {
        for (String nonTerminal: nonTerminals) {
            List<String> rightHandSides = productionRules.get(nonTerminal);
            for (String rightSide: rightHandSides ) {
                if (rightSide.length() == 1 && Character.isLowerCase(rightSide.charAt(0))) {
                    continue;
                } else if (rightSide.length() == 2) {
                    char firstSymbol = rightSide.charAt(0);
                    char secondSymbol = rightSide.charAt(1);
                    if (Character.isUpperCase(firstSymbol) && Character.isLowerCase(secondSymbol)){
                        continue;
                } else if (Character.isLowerCase(firstSymbol) && Character.isUpperCase(secondSymbol)){
                        continue;
                    }
                }
                return false;
            }
        }
        return true;
    }
```

```
    public boolean isContextFreeGrammar() {
        for (String nonTerminal: nonTerminals) {
            List<String> rightHandSides = productionRules.get(nonTerminal);
            for (String rightSide: rightHandSides ) {
                if (nonTerminal.length() != 1 || !Character.isUpperCase(nonTerminal.charAt(0))) {
                    return false;
                }
                for (int i = 0; i<rightSide.length(); i++){
                    char symbol = rightSide.charAt(i);
                    if (!Character.isUpperCase(symbol) && !Character.isLowerCase(symbol)){
                        return false;
                    }
                }
            }
        }
        return true;
    }
```

```
    public boolean isContextSensitiveGrammar() {
        for (String nonTerminal: nonTerminals) {
            List<String> rightHandSides = productionRules.get(nonTerminal);
            for (String rightSide: rightHandSides ) {
                if (nonTerminal.length() > rightSide.length()){
                    return false;
                }
            }
        }
        return true;
    }
```



### Finite automata to Grammar

```

public Grammar toGrammar(){
        Set<String> nonTerminals = this.states;
        Set<String> terminals = this.alphabet;
        String startSymbol = this.startState;
        Map<String, List<String>> productionRules = new HashMap<>();

        for (String state : this.states){
            for (Transition transition: this.transitions){
                if (Objects.equals(transition.getCurrentState(), state) && !Objects.equals(transition.getTransitionLabel(), "")) {
                    if (productionRules.containsKey(state)) {
                        productionRules.get(state).add(transition.getTransitionLabel() + transition.getNextState());
                    } else {
                        productionRules.put(state, 
                        new ArrayList<>(List.of(transition.getTransitionLabel() + transition.getNextState())));
                    }
                }
            }
        }
        for (String state: this.acceptStates){
            if (productionRules.containsKey(state)) {
                productionRules.get(state).add("e");
            } else {
                productionRules.put(state, new ArrayList<>(List.of("e")));
            }
        }
        return new Grammar(startSymbol, terminals, nonTerminals, productionRules);
    }

```

### Finite automata type

```

public boolean isDeterministic() {
        Set<String> seenStates = new HashSet<>();
        for (Transition transition : transitions) {
            String fromState = transition.getCurrentState();
            String input = transition.getTransitionLabel();
            String toState = transition.getNextState();

            // Check if the transition is valid
            if (!states.contains(fromState) || !states.contains(toState) || !alphabet.contains(input)) {
                return false;
            }

            // Check if this is the first transition we've seen for this state and input
            if (seenStates.contains(fromState + input)) {
                return false;
            }
            seenStates.add(fromState + input);

            // Check if this state/input pair leads to multiple states
            for (Transition otherTransition : transitions) {
                if (otherTransition.getCurrentState().equals(fromState) &&
                        otherTransition.getTransitionLabel().equals(input) &&
                        !otherTransition.getNextState().equals(toState)) {
                    return false;
                }
            }
        }

        return true;
    }
    
```

### NFA to DFA

```
public FiniteAutomaton convertToDFA() {

        FiniteAutomaton dfa = new FiniteAutomaton(new Transition[0]);

        Map<Set<String>, Set<String>> epsilonClosures = new HashMap<>();
        for (String state : states) {
            Set<String> closure = getEpsilonClosure(state);
            epsilonClosures.put(closure, closure);
        }
        
        Set<String> startClosure = epsilonClosures.get(getEpsilonClosure(this.startState));
        dfa.states.add(setToString(startClosure));
        dfa.startState = setToString(startClosure);
        dfa.alphabet = this.alphabet;

        // Compute the transitions for the DFA
        Set<Set<String>> unmarkedStates = new HashSet<>();
        unmarkedStates.add(startClosure);
        while (!unmarkedStates.isEmpty()) {
            Set<String> currentStateSet = unmarkedStates.iterator().next();
            unmarkedStates.remove(currentStateSet);

            for (String label : this.alphabet) {
                Set<String> nextStateSet = new HashSet<>();
                for (String state : currentStateSet) {
                    for (Transition t : this.transitions) {
                        if (t.getCurrentState().equals(state) && t.getTransitionLabel().equals(label)) {
                            Set<String> targetClosure = epsilonClosures.get(getEpsilonClosure(t.getNextState()));
                            nextStateSet.addAll(targetClosure);
                        }
                    }
                }

                if (!nextStateSet.isEmpty()) {
                    String nextStateName = setToString(nextStateSet);
                    dfa.states.add(nextStateName);

                    if (dfa.startState == null && nextStateSet.contains(this.startState)) {
                        dfa.startState = nextStateName;
                    }

                    if (isAcceptState(nextStateSet)) {
                        dfa.acceptStates.add(nextStateName);
                    }

                    String currentStateName = setToString(currentStateSet);
                    dfa.transitions = Arrays.copyOf(dfa.transitions, dfa.transitions.length + 1);
                    dfa.transitions[dfa.transitions.length - 1] = new Transition(currentStateName, nextStateName, label);

                    if (!epsilonClosures.containsKey(nextStateSet)) {
                        epsilonClosures.put(nextStateSet, nextStateSet);
                        unmarkedStates.add(nextStateSet);
                    }
                }
            }
        }

        return dfa;
    }
```

```
    private Set<String> getEpsilonClosure(String state) {
        Set<String> closure = new HashSet<>();
        closure.add(state);
        Stack<String> stack = new Stack<>();
        stack.push(state);
        while(!stack.empty()) {
            String currentState = stack.pop();
            for(Transition t : transitions) {
                if(t.getCurrentState().equals(currentState) && t.getTransitionLabel().equals("") && !closure.contains(t.getNextState())) {
                    closure.add(t.getNextState());
                    stack.push(t.getNextState());
                }
            }
        }
        return closure;
    }
```

```

    private boolean isAcceptState(Set<String> stateSet) {
        for (String state : stateSet) {
            if (acceptStates.contains(state)) {
                return true;
            }
        }
        return false;
    }
```

```
    private String setToString(Set<String> set) {
        StringBuilder sb = new StringBuilder("{");
        boolean first = true;
        for (String element : set) {
            if (!first) {
                sb.append(",");
            }
            sb.append(element);
            first = false;
        }
        sb.append("}");
        return sb.toString();
    }

```

## Results

```
Non-deterministic finite automaton

Alphabet = [a, b]
States = [q1, q2, q0]
Initial state = q0
Accepting states = [q2]
Transitions = [q1, q0, q2, q0, q1, q2]
Is the current final automaton deterministic: false

Finite automaton to grammar 

Grammar

Staring symbol = q0
Non-terminal symbols = [q1, q2, q0]
Terminal symbols = [a, b]
Production rules = {q1=[bq2, bq1], q2=[bq2, e], q0=[aq1, aq0, bq0]}

Generate words: 

bab
ab
bbbbaab
abbbb
abbb

NFA to DFA 

Deterministic Finite automaton

Alphabet = [a, b]
States = [{q1,q2,q0}, {q1,q0}, {q0}]
Initial state = {q0}
Accepting states = [{q1,q2,q0}]
Transitions = [{q1,q0}, {q0}, {q1,q0}, {q1,q2,q0}, {q1,q0}, {q1,q2,q0}]
Is the current final automaton deterministic: true

```

## Conclusion

Based on this laboratory work, I can conclude that I have successfully 
converted a Non-Deterministic Finite Automaton to a Deterministic 
Finite Automaton. 
This conversion allowed me to obtain a DFA that is equivalent to the original 
NFA in terms of language recognition.

Furthermore, I have also performed a Finite Automaton to Grammar conversion, 
where I have generated a Grammar that generates the same 
language as the given FA. This conversion allowed us to represent the language 
recognized by the FA in a different form, which can be useful in various applications, 
including parsing.

After analyzing the obtained results, we have determined that the original NFA was a 
type of Non-Deterministic Finite Automaton, and the converted DFA is a type of 
Deterministic Finite Automaton. Additionally, the generated CFG is a type of 
Context-Free Grammar.

In conclusion, this laboratory work has provided us with valuable insights 
into the conversion of NFAs to DFAs and FAs to CFGs, which are important concepts 
in theoretical computer science. We have successfully applied these concepts and 
techniques to solve problems related to language recognition and representation.