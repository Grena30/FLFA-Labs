#  Chomsky Normal Form

## Course: Formal Languages & Finite Automata
## Author: Gutu Dinu
## Variant: 19

---

## Theory

Chomsky Normal Form (CNF) is a type of grammar that is widely used in formal language theory and 
computational linguistics. This form of grammar is named after the famous linguist Noam Chomsky, 
who first introduced it as a way to study the syntactic structure of natural languages.

A grammar is said to be in Chomsky Normal Form if all its production rules are of the form A → SB or A → a, 
where A, B, and S are non-terminal symbols and a is a terminal symbol. In other words, every non-terminal 
symbol in a CNF grammar produces either two non-terminals or a single terminal symbol.

The use of CNF grammars is advantageous for several reasons. Firstly, it simplifies the process of 
parsing a sentence, which is essential for natural language processing. CNF grammars can be parsed 
efficiently in O(n^3) time, where n is the length of the input sentence. This is because the use of 
binary productions eliminates the need for backtracking, which can be a significant bottleneck in parsing.

Secondly, CNF grammars are easy to analyze and manipulate. For example, it is straightforward to determine 
whether a given string is derivable from a CNF grammar by using dynamic programming techniques. 
This makes it possible to perform various operations on CNF grammars, such as converting them 
to other forms or optimizing them for specific tasks.

Finally, CNF grammars have a close relationship with context-free languages, which are a 
fundamental class of languages in formal language theory. Every context-free grammar can be 
transformed into an equivalent CNF grammar, and every context-free language can be generated by a 
CNF grammar. This means that CNF grammars provide a powerful tool for studying the properties of context-free languages.



## Objectives:

1. Learn about Chomsky Normal Form (CNF).

2. Get familiar with the approaches of normalizing a grammar.

3. Implement a method for normalizing an input grammar by the rules of CNF.

   I. The implementation needs to be encapsulated in a method with an appropriate signature (also ideally in an appropriate class/type).

   II. The implemented functionality needs executed and tested.

   III. Bonus Point for implementing unit tests that validate the functionality of the project.

   IV. Another Bonus Point for making the previous mentioned function to accept any grammar.

## Implementation description

### Remove epsilon productions

* The following function goes through all the productions and where it finds an epsilon production it removes it and for.
each other production that also was connected to the epsilon one is added a new production without the connector to the epsilon production.

```
    for (String nonTerminal : nonTerminals) {
        for (String production : productions) {
            .....
            
            if (production.isEmpty()) {
                // Remove epsilon production
                productionRules.get(nonTerminal).remove("");
                
            } else {
                // Remove nullable symbols from production
                for (int i = 0; i < production.length(); i++) {
                    if (nullableSymbols.contains(String.valueOf(production.charAt(i)))) {
                        .....
                        
                        if (!newProduction.isEmpty() && !productionRules.get(nonTerminal).contains(newProduction)) {
                            .....
```


### Remove null productions

* This function is only for specific cases, it checks if there are any empty production rules after the epsilon removal.

```
    for (String nonTerminal_null : nullableSymbols) {
    
        // Check if there are no productions in this non-terminal form the null-list
        if (productions_nullable.isEmpty()) {
    
            // Remove the non-terminal and all of its other usages from production rules and non-terminal symbols
            productionRules.remove(nonTerminal_null);
            nonTerminals.remove(nonTerminal_null);
    
            // Iterate through all the non-terminals and remove productions that contain the null-term
            for (String nonTerminal : nonTerminals) {
                for (String production : productions) {
                    if (production.contains(nonTerminal_null)) {
                        productionRules.get(nonTerminal).remove(production);
```

### Remove unit productions

* Unit productions are productions of the form A->B.
* This functions removes such rules by simply adding the productions of the unit productions.

```
    // Find unit productions
    for (String nonTerminal : nonTerminals) {
        for (String production : productionRules.get(nonTerminal)) {
            .....
            
        unitProductions.put(nonTerminal, unitNonTerminals);

    // Add the production rules of unit productions
    // And the remove unit productions
    for (String nonTerminal : nonTerminals) {
        Set<String> unitNonTerminals = unitProductions.get(nonTerminal);
        if (!unitNonTerminals.isEmpty()) {
            .....
            
            productionRules.get(nonTerminal).remove(unit);
            unitProductions.get(nonTerminal).remove(unit);
```

### Remove unproductive symbols

* This function removes the symbols that do not reach a terminal variable or 
are not connected to another symbol which has terminal production rules.

```
    // Set all the non-terminals to unproductive
    for (String nonTerminal : nonTerminals) {
        productive.put(nonTerminal, false);

    // Check for single terminal symbols in each non-terminal
    for (String nonTerminal : nonTerminals) {
        for (String production : productionRules.get(nonTerminal)) {
            if (terminals.contains(production)) {
                productive.put(nonTerminal, true);
      
    // Check for productive non-terminals in all the unproductive terminals
    for (String nonTerminal : nonTerminals) {
        boolean productiveSymbol = false;
        if (productive.get(nonTerminal)) {
            .....
            
        productive.put(nonTerminal, productiveSymbol);

    // Build the new production rules with only the productive non-terminals
    if (!(count == productive.size())) {
    
        Map<String, List<String>> newProductions = new HashMap<>();
        for (String nonTerminal : nonTerminals) {
            List<String> empty = new ArrayList<>();
            for (String production : productionRules.get(nonTerminal)) {
                .....
```

### Remove inaccessible symbols

* This functions looks through production rules and if it finds an unreachable symbol it removes it.

```
    // Check for each non-terminal if there is a way to get to it
    for (String nonTerminal : nonTerminals) {
        String current = nonTerminal;
        for (String nonTerminal2 : nonTerminals) {
            String check = nonTerminal2;
            .....
            
            for (String production : productionRules.get(check)) {
                if (production.contains(current) && !accessibleSymbols.contains(current)) {
                    accessibleSymbols.add(current);
                    .....
    
        // Remove all the non-terminal symbols that are unreachable
        for (String nonTerminal : nonTerminals) {
            if (!accessibleSymbols.contains(nonTerminal)) {
                productionRules.remove(nonTerminal);
                nonTerminals.remove(nonTerminal);
```


### To Chomsky Normal Form conversion

* After having done all the previous steps this functions aims to convert all other production lists to be of the form A ->BC or A->a.
* It does that by adding new production rules for all the other parts that do not conform to CNF until it reaches the desired form.
```
    for (String nonTerminal: nonTerminals) {
        for (String production : productionRules.get(nonTerminal)) {

            // More than two symbols
            if (production.length() > 2 && production.matches("[a-z][A-Z][a-z][A-Z]+")) {
        
                // Iterate through the production's characters
                for (int i = 0; i < production.length(); i++) {
                    String oldSymbol = String.valueOf(production.charAt(i));
                    .....
        
        
            // For terminal + non-terminal
            if (production.matches("[a-z][A-Z]")) {
                String keyValue = null;
        
        
                // Verify if the terminal was already added
                String terminal = String.valueOf(production.charAt(0));
                if (!changedProductions.containsValue(terminal)) {
                    .....
        
                // Add the new-made production to the production rules
                .....                   

    // Update the existing production rules with the added productions
    for (String nonTerminal: nonTerminals){
        for (String production: productionRules.get(nonTerminal)){
            for (String changedProduction: changedProductions.keySet()){
                .....

```

## Results

```

INITIAL FORM
Starting symbol: S
Terminals: [a, d]
Non-terminals: [A, B, S, C, E]
Production rules: {A=[d, dS, aAdCB], B=[aC, dA, AC], S=[dB, B], C=[], E=[AS]}

AFTER REMOVING EPSILON PRODUCTIONS
Starting symbol: S
Terminals: [a, d]
Non-terminals: [A, B, S, C, E]
Production rules: {A=[d, dS, aAdCB, aAdB], B=[aC, dA, AC, a, A], S=[dB, B], C=[], E=[AS]}

AFTER REMOVING NULL SYMBOLS
Starting symbol: S
Terminals: [a, d]
Non-terminals: [A, B, S, E]
Production rules: {A=[d, dS, aAdB], B=[dA, a, A], S=[dB, B], E=[AS]}

AFTER REMOVING UNIT PRODUCTIONS
Starting symbol: S
Terminals: [a, d]
Non-terminals: [A, B, S, E]
Production rules: {A=[d, dS, aAdB], B=[dA, a, d, dS, aAdB], S=[dB, dA, a, d, dS, aAdB], E=[AS]}

AFTER REMOVING NON-PRODUCTIVE SYMBOLS
Starting symbol: S
Terminals: [a, d]
Non-terminals: [A, B, S, E]
Production rules: {A=[d, dS, aAdB], B=[dA, a, d, dS, aAdB], S=[dB, dA, a, d, dS, aAdB], E=[AS]}

AFTER REMOVING INACCESSIBLE SYMBOLS
Starting symbol: S
Terminals: [a, d]
Non-terminals: [A, B, S]
Production rules: {A=[d, dS, aAdB], B=[dA, a, d, dS, aAdB], S=[dB, dA, a, d, dS, aAdB]}

AFTER CHOMSKY NORMAL FORM CONVERSION
Starting symbol: S
Terminals: [a, d]
Non-terminals: [A, B, S, W, X, Y, Z]
Production rules: {A=[d, ZS, XW], B=[ZA, a, d, ZS, XW], S=[ZB, ZA, a, d, ZS, XW], W=[ZB], X=[YA], Y=[a], Z=[d]}

```

## Unit Tests

Unit testing is a software testing technique in which individual units or components of a software application are tested in isolation from 
the rest of the system. 
A unit is the smallest testable part of any software application.

### Grammar tests

* generateWord
* toFiniteAutomaton
* getGrammarType
* convertToChomskyNormalForm

### Finite automaton tests

* isWordValid
* toGrammar
* toDFA
* isDeterministic

## Conclusion

In conclusion, the Chomsky Normal Form (CNF) is an important concept 
in formal language theory and computational linguistics. 
CNF conversion is the process of transforming a context-free 
grammar into an equivalent grammar in CNF. This process involves 
several steps, including removing epsilon productions, unit productions, 
and non-productive symbols, and then replacing each production with binary 
productions. The resulting CNF grammar is easier to analyze and manipulate, 
which makes it a valuable tool for various applications such as natural language 
processing and compiler design. The conversion of a context-free grammar to CNF can be challenging for complex 
grammars, but it is essential for efficient parsing and other applications. 

In this project, I have explored the process of CNF conversion in detail, 
covering the steps involved, the algorithms used, and the applications of CNF 
grammars. In addition to that, I have also implemented a CNF conversion algorithm and tested it. 
Overall, this project has provided a comprehensive understanding of CNF 
conversion and its importance in formal language theory and computational 
linguistics.